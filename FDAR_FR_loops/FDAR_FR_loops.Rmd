---
title: 'Boucles dans R'
output:
  html_document:
    number_sections: true
    toc: true
    toc_float: true
    css: !expr here::here("global/style/style.css")
    highlight: kate
editor_options: 
  chunk_output_type: console
---

```{r, echo = F, message = F, warning = F}
# Charger les packages
if(!require(pacman)) install.packages("pacman")
pacman::p_load(rlang, tidyverse, knitr, here, reactable, gt, flextable)

## fonctions
source(here::here("global/functions/misc_functions.R"))

## rendu par d√©faut
registerS3method("reactable_5_rows", "data.frame", reactable_5_rows)
knitr::opts_chunk$set(class.source = "tgc-code-block", error = T)

```

# Introduction

Au c≈ìur de la programmation se trouve le concept de r√©p√©ter une t√¢che plusieurs fois. Une boucle `for` est une des mani√®res fondamentales de le faire. Les boucles permettent une r√©p√©tition efficace, √©conomisant temps et effort.

Ma√Ætriser ce concept est essentiel pour √©crire du code R intelligent et efficace.

Plongeons et am√©liorez vos comp√©tences en codage !

# Objectifs d'apprentissage

√Ä la fin de cette le√ßon, vous serez capable de :

-   Expliquer la syntaxe et la structure d'une boucle `for` basique dans R
-   Utiliser des variables d'index pour it√©rer √† travers de multiples vecteurs simultan√©ment dans une boucle
-   Int√©grer des instructions conditionnelles `if/else` dans une boucle
-   Stocker les r√©sultats des boucles dans des vecteurs et des listes
-   Appliquer des boucles √† des t√¢ches comme l'analyse de multiples jeux de donn√©es et la g√©n√©ration de multiples graphiques
-   D√©boguer des boucles en isolant et en testant des it√©rations uniques

# Packages

Cette le√ßon n√©cessitera l'installation et le chargement des packages suivants :

```{r warning = F, message = F}
# Charger les packages
if(!require(pacman)) install.packages("pacman")
pacman::p_load(tidyverse, here, openxlsx, tools, outbreaks, medicaldata)
```

# Introduction aux boucles `for`

Commen√ßons par un exemple simple. Supposons que nous avons un vecteur d'√¢ges d'enfants en ann√©es, et nous voulons convertir ces √¢ges en mois :

```{r}
ages <- c(7, 8, 9) # Vecteur d'√¢ges en ann√©es
```

Nous pouvons faire cela facilement avec l'op√©ration `*` dans R :

```{r}
ages * 12
```

Mais voyons en d√©tails la mani√®re dont nous pourrions accomplir cela en utilisant une boucle `for` √† la place, car c'est (conceptuellement) ce que R fait en arri√®re plan.

```{r}
for (age in ages) print(age * 12)
```

Dans cette boucle, `age` est une variable temporaire qui prend la valeur de chaque √©l√©ment dans `ages` √† chaque it√©ration. D'abord, `age` est 7, ensuite 8, puis 9.

Vous pouvez choisir n'importe quel nom pour cette variable :

```{r}
for (nom_aleatoire in ages) print(nom_aleatoire * 12)
```

Si le contenu de la boucle est plus d'une ligne, vous devez utiliser des accolades `{}` pour indiquer le corps de la boucle.

```{r}
for (age in ages) {
  age_en_mois = age * 12
  print(age_en_mois)
}
```

La structure g√©n√©rale de n'importe quelle boucle `for` est illustr√©e dans le diagramme ci-dessous :

![](images/for_loop_syntax.png){width="420"}

::: pratique
### Boucle de base pour convertir des heures en minutes {.unlisted .unnumbered}

Essayez de convertir des heures en minutes en utilisant une boucle `for`. Commencez avec ce vecteur d'heures :

```{r eval = F}
hours <- c(3, 4, 5) # Vecteur d'heures
# Votre code ici

for ___ 
_____ # convertissez les heures en minutes et affichez
```
:::

::: note-lat√©rale
Les boucles peuvent √™tre imbriqu√©es les unes dans les autres. Par exemple :

```{r}
for (i in 1:2) {
  for (j in 1:2) {
    print(i * j)
  }
}
```

Cela cr√©e une combinaison de valeurs `i` et `j` comme le montre ce tableau :

| i   | j   | i \* j |
|-----|-----|--------|
| 1   | 1   | 1      |
| 1   | 2   | 2      |
| 2   | 1   | 2      |
| 2   | 2   | 4      |

Les boucles imbriqu√©es sont cependant moins courantes et ont souvent des alternatives plus efficaces.
:::

# Les boucles `for` sont-elles utiles en R ?

Bien que les boucles `for` soient fondamentales dans de nombreux langages de programmation, leur utilisation en R est quelque peu moins fr√©quente. Cela est d√ª au fait que R g√®re intrins√®quement les op√©rations *vectoris√©es*, en appliquant automatiquement une fonction √† chaque √©l√©ment d'un vecteur.

Par exemple, notre conversion initiale d'√¢ge pourrait √™tre r√©alis√©e sans boucle :

```{r}
ages * 12
```

De plus, R traite g√©n√©ralement avec des jeux de donn√©es plut√¥t qu'avec des vecteurs bruts. Pour les jeux de donn√©es, nous utilisons souvent des fonctions du package `tidyverse` pour appliquer des op√©rations sur les colonnes :

```{r}
ages_df <- tibble(age = ages)
ages_df %>% 
  mutate(age_months = age * 12)
```

Cependant, il existe des situations o√π les boucles sont utiles, en particulier lorsqu'on travaille avec plusieurs jeux de donn√©es ou des objets non-dataframe (parfois appel√©s objets *non rectangulaires*).

Nous explorerons ces cas plus loin dans la le√ßon, mais d'abord nous allons passer plus de temps √† nous familiariser avec les boucles en utilisant des exemples de simulation.

::: astuce-pro
**Boucles vs cartographie des fonctions**

Il est important de noter que les boucles peuvent souvent √™tre remplac√©es par des fonctions personnalis√©es qui sont ensuite appliqu√©es √† travers un vecteur ou un jeu de donn√©es.

Nous enseignons n√©anmoins les boucles parce qu'elles sont assez faciles √† apprendre, √† comprendre et √† d√©boguer, m√™me pour les d√©butants.
:::


# Boucler avec un Index

Il est souvent utile de parcourir un vecteur en utilisant un index, qui est un compteur qui suit l'it√©ration en cours.

Regardons √† nouveau notre vecteur `ages` que nous voulons convertir en mois :

```{r}
ages <- c(7, 8, 9) # Vecteur d'√¢ges en ann√©es
```

Pour utiliser des index dans une boucle, nous cr√©ons d'abord une s√©quence qui repr√©sente chaque position dans le vecteur :

```{r}
1:length(ages) # Cr√©e une s√©quence d'index de la m√™me longueur que ages
index <- 1:length(ages)
```

Maintenant, `index` a les valeurs 1, 2, 3, correspondant aux positions dans `ages`. Nous utilisons ceci dans une boucle `for` comme suit :

```{r}
for (i in index) {
  print(ages[i] * 12)
}
```

Dans ce code, `ages[i]` fait r√©f√©rence au `i`√®me √©l√©ment de notre liste `ages`.

Le nom de la variable `i` est arbitraire. Nous aurions pu utiliser `j` ou `index` ou `position` ou tout autre nom.

```{r}
for (position in index) {
  print(ages[position] * 12)
}
```

Souvent, nous n'avons pas besoin de cr√©er une variable s√©par√©e pour les index. Nous pouvons simplement

Des boucles bas√©es sur les index sont utiles pour travailler avec plusieurs vecteurs en m√™me temps. Nous verrons cela dans la section suivante.

::: pratique
### Boucle index√©e d'heures en minutes {.unlisted .unnumbered}

R√©√©crivez votre boucle de la derni√®re question en utilisant des index :

```{r, eval = F}
heures <- c(3, 4, 5) # Vecteur d'heures

# Votre code ici

for ___ {
  ___
}
```
:::

::: note
La fonction `seq_along()` est un raccourci pour cr√©er une s√©quence d'index. Elle est √©quivalente √† `1:length()` :

```{r}
# Ces deux sont √©quivalents :
seq_along(ages)
1:length(ages)
```
:::


# Faire des boucles sur plusieurs vecteurs

Faire des boucles avec des index nous permet de travailler avec plusieurs vecteurs simultan√©ment. Supposons que nous ayons des vecteurs pour les √¢ges et les tailles :

```{r}
ages <- c(7, 8, 9) # √¢ges en ann√©es
tailles <- c(120, 130, 140) # tailles en cm
```

Nous pouvons faire des boucles sur les deux en utilisant la m√©thode d'index :

```{r}
for(i in 1:length(ages)) {
  age <- ages[i]
  taille <- tailles[i]
  
  print(paste("√Çge :", age, "Taille :", taille))
}
```

√Ä chaque it√©ration : - `i` est l'index - Nous extrayons le i-√®me √©l√©ment de chaque vecteur

et l'imprimons.

Alternativement, nous pouvons sauter l'assignation de variable et utiliser les index directement dans la fonction `print()` :

```{r}
for(i in 1:length(ages)) {
  print(paste("√Çge :", ages[i], "Taille :", tailles[i]))
}
```

::: pratique
### Boucle de calcul de l'IMC {.unlisted .unnumbered}

En utilisant une boucle for, calculez l'Indice de Masse Corporelle (IMC) des trois individus ci-dessous. La formule de l'IMC est `IMC = poids / (taille ^ 2)`.

```{r eval = F}
poids <- c(30, 32, 35) # Poids en kg
tailles <- c(1.2, 1.3, 1.4) # Tailles en m√®tres

for(i in ____________________) {

  __________________________
  
  print(paste("Poids :", ____,
              "Taille :", ____,
              "IMC :", ____,
              ))
  
}

```
:::

# Stocker les r√©sultats d'une boucle

Dans la plupart des cas, vous voudrez stocker les r√©sultats d'une boucle plut√¥t que de les imprimer comme nous l'avons fait ci-dessus. Voyons comment faire cela.

Consid√©rons notre exemple de conversion d'√¢ge en mois :

```{r}
ages <- c(7, 8, 9) 

for (age in ages) {
  print(paste(age * 12, "mois"))
}
```

Pour stocker ces √¢ges convertis, nous cr√©ons d'abord un vecteur vide :

```{r}
ages_mois <- vector(mode = "numeric", length = length(ages))
# Cela peut aussi √™tre √©crit comme :
ages_mois <- vector("numeric", length(ages))

ages_mois # Affiche le vecteur vide
```

Cela cr√©e un vecteur num√©rique de la m√™me longueur que `ages`, initialement rempli de z√©ros. Pour stocker une valeur dans le vecteur, nous faisons ce qui suit :

```{r}
ages_mois[1] <- 99 # Stocker 99 dans le premier √©l√©ment de ages_mois
ages_mois[2] <- 100 # Stocker 100 dans le deuxi√®me √©l√©ment de ages_mois
ages_mois
```

Maintenant, ex√©cutons la boucle, en stockant les r√©sultats dans `ages_mois` :

```{r}
ages_mois <- vector("numeric", length(ages))

for (i in 1:length(ages)) {
  ages_mois[i] <- ages[i] * 12
}
ages_mois 
```

Dans cette boucle :

- Lors de la premi√®re it√©ration, `i` est 1. Nous multiplions le premier √©l√©ment de `ages` par 12 et le stockons dans le premier √©l√©ment de `ages_mois`.
- Ensuite `i` est 2, puis 3. √Ä chaque it√©ration, nous multiplions l'√©l√©ment correspondant de `ages` par 12 et le stockons dans l'√©l√©ment correspondant de `ages_mois`.

::: pratique
### Conversion de la taille de cm en m {.unlisted .unnumbered}

Utilisez une boucle for pour convertir les mesures de taille de cm en m. Stockez les r√©sultats dans un vecteur appel√© `height_meters`.

```{r}
height_cm <- c(180, 170, 190, 160, 150) # Tailles en cm

height_m <- vector(_______________) # vecteur num√©rique de m√™me longueur que height_cm

for ___ {
  height_m[i] <- ________________________
}
```
:::

::: attention
Afin de sauvegarder les r√©sultats de votre it√©ration, vous devez cr√©er votre objet vide **√† l'ext√©rieur** de la boucle. Sinon, vous ne sauvegarderez que le r√©sultat de la derni√®re it√©ration.

C'est une erreur commune. Consid√©rez l'exemple ci-dessous :

```{r}
ages <- c(7, 8, 9)

for (i in 1:length(ages)) {
  ages_mois <- vector("numeric", length(ages))
  ages_mois[i] <- ages[i] * 12
}
ages_mois 
```

Voyez-vous le probl√®me ?
:::

::: note lat√©rale
Si vous √™tes press√©, vous pouvez sauter l'utilisation de la fonction `vector()` et initialiser votre vecteur avec `c()` √† la place, puis le remplir progressivement avec des valeurs par index :

```{r}
ages_mois <- c()

for (i in 1:length(ages)) {
  ages_mois[i] <- ages[i] * 12
}
ages_mois
```

Et vous pouvez √©galement sauter l'index et utiliser `c()` pour ajouter des valeurs √† la fin du vecteur :

```{r}
ages_mois <- c()

for (age in ages) {
  ages_mois <- c(ages_mois, age * 12)
}
ages_mois
```

Cependant, dans les deux cas, R ne conna√Æt pas la longueur finale du vecteur lorsqu'il passe par les it√©rations, il doit donc r√©allouer la m√©moire √† chaque it√©ration. Cela peut entra√Æner des performances lentes si vous travaillez avec de grands vecteurs.
:::

# Instructions conditionnelles dans les boucles

Tout comme les instructions `if` peuvent √™tre utilis√©es dans les fonctions, elles peuvent √™tre int√©gr√©es dans les boucles.

Consid√©rez cet exemple :

```{r}
age_vec <- c(2, 12, 17, 24, 60) # Vecteur d'√¢ges

for (age in age_vec) {
  if (age < 18) print(paste("Enfant, √Çge", age ))
}
```

Il est souvent plus clair d'utiliser des accolades pour indiquer le corps de l'instruction `if`. Cela nous permet √©galement d'ajouter plus de lignes de code au corps de l'instruction `if` :

```{r}
for (age in age_vec) {
  if (age < 18) {
    print("Traitement :")
    print(paste("Enfant, √Çge", age ))
  }
}
```

Ajoutons une autre condition pour classer comme 'Enfant' ou 'Adolescent' :

```{r}
for (age in age_vec) {
  if (age < 13) {
    print(paste("Enfant, √Çge", age))
  } else if (age >= 13 && age < 18) {
    print(paste("Adolescent, √Çge", age))
  }
}
```

Nous pouvons inclure une seule instruction `else` √† la fin pour prendre en compte toutes les autres tranches d'√¢ge :

```{r}
for (age in age_vec) {
  if (age < 13) {
    print(paste("Enfant, √Çge", age))
  } else if (age >= 13 && age < 18) {
    print(paste("Adolescent, √Çge", age))
  } else {
    print(paste("Adulte, √Çge", age))
  }
}
```

Pour stocker ces classifications, nous pouvons cr√©er un vecteur vide et utiliser une boucle bas√©e sur l'index pour stocker les r√©sultats :

```{r}
age_class <- vector("character", length(age_vec)) # Cr√©er un vecteur vide
for (i in 1:length(age_vec)) {
  if (age_vec[i] < 13) {
    age_class[i] <- "Enfant" # Enfant
  } else if (age_vec[i] >= 13 && age_vec[i] < 18) {
    age_class[i] <- "Adolescent" # Adolescent
  } else {
    age_class[i] <- "Adulte" # Adulte
  }
}
age_class
```

::: pratique
### Classification de la temp√©rature {.unlisted .unnumbered}

Vous disposez d'un vecteur de temp√©ratures corporelles en Celsius. Classez chaque temp√©rature comme 'Hypothermie', 'Normale' ou 'Fi√®vre' en utilisant une boucle `for` combin√©e avec des instructions `if` et `else`.

Utilisez ces r√®gles :

- En dessous de 36,5 ¬∞C : 'Hypothermie' (Hypothermie)
- Entre 36,5 ¬∞C et 37,5 ¬∞C : 'Normale' (Normale)
- Au-dessus de 37,5 ¬∞C : 'Fi√®vre' (Fi√®vre)

```{r}
body_temps <- c(35, 36.5, 37, 38, 39.5) # Temp√©ratures corporelles en Celsius
classif_vec <- vector(______________________) # vec caract√®re, longueur de body_temps
for (i in 1:length(________)) {
    # Ajoutez votre logique if-else ici
  if (tempe_corporelle[i] < 36.5) {
    out <- "Hypothermie" # Hypothermie
  } ## ajoutez d'autres conditions
  
  
    # Derni√®re instruction d'impression
    classif_vec[i] <- paste(tempe_corporelle[i], "¬∞C est", out)
}
classif_vec
```

Un r√©sultat attendu est ci-dessous

```         
35¬∞C est Hypothermie
36.5¬∞C est Normale  
37¬∞C est Normale
38¬∞C est Fi√®vre
39.5¬∞C est Fi√®vre
```
:::

# Techniques rapides pour d√©boguer des boucles `for`

L'√©dition et le d√©bogage efficaces sont cruciaux lorsqu'on travaille avec des boucles `for` en R. Il existe de nombreuses approches pour cela, mais pour le moment, nous allons montrer deux des plus simples :

- Isoler et ex√©cuter une seule it√©ration de la boucle
- Ajouter des instructions `print()` √† la boucle pour imprimer les valeurs des variables √† chaque it√©ration

## Isoler et ex√©cuter une seule it√©ration

Consid√©rez cette boucle que nous avons vue pr√©c√©demment :

```{r}
age_vec <- c(2, 12, 17, 24, 60) # Vecteur d'√¢ges
age_class <- vector("character", length(age_vec))

for (i in 1:length(age_vec)) {
  if (age_vec[i] < 18) {
    age_class[i] <- "Enfant" # Enfant
  } else {
    age_class[i] <- "Adulte" # Adulte
  }
}
age_class
```

Voyons un exemple d'erreur que nous pourrions rencontrer en utilisant la boucle :

```{r}
# Vecteur d'√¢ge issu du jeu de donn√©es fluH7N9_china_2013
flu_dat <- outbreaks::fluH7N9_china_2013
head(flu_dat)

flu_dat_age <- flu_dat$age
age_class <- vector("character", length(flu_dat_age))
for (i in 1:length(flu_dat_age)) {
  if (flu_dat_age[i] < 18) {
    age_class[i] <- "Enfant" # Enfant
  } else {
    age_class[i] <- "Adulte" # Adulte
  }
}
```

Nous obtenons cette erreur :

```
Erreur dans if (flu_dat_age[i] < 18) { : 
  valeur manquante l√† o√π TRUE / FALSE est requis
De plus : Message d'avis :
Dans Ops.factor(flu_dat_age[i], 18) :
  ‚Äò<‚Äô n'est pas pertinent pour des variables facteurs
```

Vous savez peut-√™tre d√©j√† ce que signifie cette erreur, mais supposons que vous ne le sachiez pas.

Nous pouvons entrer dans la boucle et parcourir manuellement la premi√®re it√©ration pour voir ce qui se passe :

```{r}
for (i in 1:length(flu_dat_age)) {
  
  # ‚ñ∂Ô∏è Ex√©cutez √† partir de cette ligne
  i <- 1 # D√©finir manuellement i √† 1
  
  # Ensuite, surlignez `flu_dat_age[i]` et appuyez sur Ctrl + Entr√©e pour ex√©cuter juste ce code
  # Apr√®s cela, surlignez et ex√©cutez `flu_dat_age[i] < 18`
  
  if (flu_dat_age[i] < 18) {
    age_class[i] <- "Enfant" # Enfant
  } else {
    age_class[i] <- "Adulte" # Adulte
  }
  
}
```

En suivant le processus ci-dessus, nous pouvons voir que `flu_dat_age` est un facteur, et non un vecteur num√©rique. Nous pouvons manuellement changer cela, en plein milieu du processus de d√©bogage. C'est une bonne id√©e de convertir d'abord le facteur en vecteur de caract√®res, puis en vecteur num√©rique. Sinon, nous pourrions obtenir des r√©sultats inattendus.

Consid√©rez :

```{r}
flu_dat_age[75]
as.numeric(flu_dat_age[75])
# `?`, qui signifie manquant dans ce cas, est converti en 1, car il est le premier niveau du facteur

# Nous avons donc besoin :
as.numeric(as.character(flu_dat_age[75]))
```

Maintenant essayons de corriger la boucle, et ex√©cutons juste la premi√®re it√©ration √† nouveau :

```{r eval = F}
for (i in 1:length(flu_dat_age)) {
  
  # ‚ñ∂Ô∏è Ex√©cuter √† partir de cette ligne
  i <- 1 # Fixer manuellement i √† 1
  
  age_num <- as.numeric(as.character(flu_dat_age[i]))
  
  # Ensuite, surligner `age_num < 18` et appuyer sur Ctrl + Entr√©e
  if (age_num < 18) {
    age_class[i] <- "Enfant"
  } else {
    age_class[i] <- "Adulte"
  }
  
}
```

Maintenant, la premi√®re it√©ration fonctionne, mais voyons ce qui se passe lorsque nous ex√©cutons la boucle enti√®re :

```{r eval = F}
age_class <- vector("character", length(flu_dat_age))

for (i in 1:length(flu_dat_age)) {
  age_num <- as.numeric(as.character(flu_dat_age[i]))
  
  if (age_num < 18) {
    age_class[i] <- "Enfant"
  } else {
    age_class[i] <- "Adulte"
  }
}
head(age_class)
```

```
Erreur dans if (age_num < 18) { : 
  valeur manquante l√† o√π TRUE / FALSE est requis
De plus : Message d'avis :
Dans as.numeric(as.character(flu_dat_age[i])) :
  NAs introduits lors de la conversion automatique
```

Encore une fois, vous savez peut-√™tre d√©j√† ce que signifie cette erreur, mais supposons que non. Nous allons essayer notre prochaine technique de d√©bogage.

## Ajouter des Instructions d'Impression √† la Boucle

Dans la derni√®re section, nous avons vu que la boucle fonctionne bien pour la premi√®re it√©ration, mais semble √©chouer lors d'une it√©ration ult√©rieure.

Pour d√©tecter sur quelle it√©ration elle √©choue, nous pouvons ajouter des instructions `print()` √† la boucle :

```{r eval = F}
for (i in 1:length(flu_dat_age)) {
  
  print(i) # Imprimer le num√©ro de l'it√©ration
  age_num <- as.numeric(as.character(flu_dat_age[i]))
  
  print(age_num) # Imprimer la valeur de age_num
  
  if (age_num < 18) {
    age_class[i] <- "Enfant"
  } else {
    age_class[i] <- "Adulte"
  }
  
  print(age_class[i]) # Imprimer la valeur de la sortie
}
head(age_class)
```

Maintenant, en inspectant la sortie, nous pouvons voir que la boucle √©choue √† la 74√®me it√©ration :

```
[1] 73 üëà 73√®me it√©ration
[1] 43 üëà Valeur de age_num
[1] "Adulte, √Çge 43" üëà Valeur de la sortie √† la 73√®me it√©ration
[1] 74 üëà 74√®me it√©ration
[1] NA üëà Valeur de age_num
```

Cela se produit parce que la 74√®me valeur de `flu_dat_age` est `NA` (√† cause de notre conversion de facteur en num√©rique), donc R ne peut pas √©valuer si elle est inf√©rieure √† 18.

Nous pouvons corriger cela en ajoutant une instruction `if` pour v√©rifier les valeurs `NA` :

```{r}
for (i in 1:length(flu_dat_age)) {
  
  age_num <- as.numeric(as.character(flu_dat_age[i]))
  
  if (is.na(age_num)) {
    age_class[i] <- "NA"
  } else if (age_num < 18) {
    age_class[i] <- "Enfant"
  } else {
    age_class[i] <- "Adulte"
  }
}
# V√©rifier la 74√®me valeur de age_class
age_class[74]
```

Super ! Maintenant, nous avons corrig√© l'erreur.

Comme vous pouvez le voir, m√™me avec notre boucle "jouet", le d√©bogage peut √™tre un processus long. Comme le disait votre m√®re : "La programmation, c'est 98 % de d√©bogage et 2 % d'√©criture de code."

::: conseil-pro
R offre plusieurs autres techniques pour diagnostiquer et g√©rer les erreurs :

-   Les fonctions `try()` et `tryCatch()` permettent de capturer les erreurs tout en continuant l'ex√©cution de la boucle.
-   La fonction `browser()` met la boucle en pause √† un point d√©sign√©, permettant une ex√©cution pas √† pas.

Ce sont des m√©thodes plus avanc√©es, et bien quelles ne soient pas couvertes ici, vous pouvez vous r√©f√©rer √† la documentation de R pour des conseils suppl√©mentaires lorsque cela est n√©cessaire. Ou consultez le livre [Advanced R](https://adv-r.hadley.nz/) de Hadley Wickham.

:::

# Application R√©elle des Boucles 1 : Analyser Plusieurs Jeux de Donn√©es

Maintenant que vous avez une solide compr√©hension des boucles `for`, appliquons nos connaissances √† une t√¢che de boucle plus r√©aliste : travailler avec plusieurs jeux de donn√©es.

Nous avons un dossier de fichiers CSV contenant des donn√©es sur les d√©c√®s li√©s au VIH pour les municipalit√©s de Colombie.

![](images/colombia_folder_struct-01.jpg){width="521"}

Imaginez que nous devions compiler un seul tableau comprenant les informations suivantes pour chaque jeu de donn√©es : le nombre de lignes (nombre de d√©c√®s), le nombre de colonnes et les noms de toutes les colonnes.

Nous pourrions faire cela un par un, mais cela serait fastidieux et source d'erreurs. Au lieu de cela, nous pouvons utiliser une boucle pour automatiser le processus.

Tout d'abord, listons les fichiers dans le dossier :

```{r}
chemins_donnees_colom <- list.files(here("data/colombia_hiv_deaths"), 
                                    full.names = TRUE)
head(chemins_donnees_colom) # Montrer les 6 premiers chemins de fichiers
```

Maintenant, importons un jeu de donn√©es comme exemple pour d√©montrer ce que nous voulons atteindre. Une fois cela fait, nous pourrons appliquer le m√™me processus √† tous les jeux de donn√©es.

```{r}
donnees_colom <- read_csv(chemins_donnees_colom[1]) # Importer le premier jeu de donn√©es
donnees_colom
```

Ensuite, nous appliquons une s√©rie de fonctions R pour recueillir les informations que nous voulons de chaque jeu de donn√©es :

```{r}
file_path_sans_ext(basename(chemins_donnees_colom[1]))  # Nom du jeu de donn√©es/municipalit√©
nrow(donnees_colom) # Nombre de lignes, ce qui √©quivaut au nombre de d√©c√®s
ncol(donnees_colom) # Nombre de colonnes
paste(names(donnees_colom), collapse = ", ") # Noms de toutes les colonnes
```

::: note-lat√©rale
`basename` : extrait le nom de fichier d'un chemin de fichier.

```{r}
chemins_donnees_colom[1]
basename(chemins_donnees_colom[1])
```

Et `file_path_sans_ext` du package {tools} supprime l'extension de fichier des noms de fichiers. Nous l'utilisons avec `basename` pour obtenir le nom de la municipalit√©.

```{r}
file_path_sans_ext(basename(chemins_donnees_colom[1]))
```
:::

Maintenant, nous devons cr√©er un dataframe avec ces informations. Nous pouvons utiliser la fonction `tibble` pour faire cela :

```{r}
ligne_unique <- 
  tibble(jeu_de_donnees = basename(chemins_donnees_colom[1]),
         n_deces = nrow(donnees_colom),
         n_colonnes = ncol(donnees_colom),
         noms_colonnes = paste(names(donnees_colom), collapse = ", "))
ligne_unique
```

Nous allons donc devoir r√©p√©ter ce processus pour chaque jeu de donn√©es. Dans la boucle, nous stockerons chaque dataframe √† une seule ligne dans une liste, puis les combinerons √† la fin. Rappelons que les listes sont des objets R qui peuvent contenir d'autres objets R, y compris des dataframes.

Initialisons cette liste vide maintenant :

```{r}
liste_dataframes <- vector("list", length(chemins_donnees_colom))
head(liste_dataframes) # Montrer les 6 premiers √©l√©ments
```

Ajoutons la premi√®re dataframe √† une seule ligne √† la liste :

```{r}
liste_dataframes[[1]] <- ligne_unique
```

Maintenant, si nous regardons la liste, nous voyons que le premier √©l√©ment est la dataframe √† une seule ligne :

```{r}
head(liste_dataframes)
```

Et nous pouvons acc√©der √† la dataframe en sous-ensemble de la liste :

```{r}
liste_dataframes[[1]]
```

Notez l'utilisation de doubles crochets pour acc√©der aux √©l√©ments de la liste.

Nous avons maintenant toutes les pi√®ces dont nous avons besoin pour cr√©er une boucle qui traitera chaque jeu de donn√©es et stockera les r√©sultats dans une liste. Allons-y !

```{r, message=FALSE}
for (i in 1:length(chemins_donnees_colom)) {
    chemin <- chemins_donnees_colom[i]

    # Importation
    donnees_colom <- read_csv(chemin)
   
    # R√©cup√©ration des infos
    n_deces <- nrow(donnees_colom)
    n_colonnes <- ncol(donnees_colom)
    noms_colonnes <- paste(names(donnees_colom), collapse = ", ")
  
    # Cr√©ation du dataframe pour cet ensemble de donn√©es
    ligne_donnees_vih <- tibble(jjeu_de_donnees = file_path_sans_ext(basename(chemin)),
                          n_deces = n_deces,
                          n_colonnes = n_colonnes,
                          noms_colonnes = noms_colonnes)
  
    # Stockage dans la liste
    liste_dataframes[[i]] <- ligne_donnees_vih
}
```

V√©rifions la liste :

```{r}
head(liste_dataframes, 2) # Montrer les 2 premiers √©l√©ments
```

Et maintenant, nous pouvons combiner tous les dataframes de la liste en un seul dataframe final. Cela peut √™tre fait avec la fonction `bind_rows` du package {dplyr} :

```{r, message=FALSE}
donnees_colom_finales <- bind_rows(liste_dataframes)
donnees_colom_finales
```


::: pratique

### Propri√©t√©s du fichier {.nonlist√© .nonnum√©rot√©}

Vous avez un dossier contenant des fichiers CSV avec des donn√©es sur les cas de VIH, provenant de [l'OMS](https://www.who.int/data/gho/data/indicators/indicator-details/GHO/number-of-new-hiv-infections).

![](images/hiv_csvs_folder.jpg){width="373"}

En utilisant les principes appris, vous √©crirez une boucle qui extrait les informations suivantes de chaque jeu de donn√©es et les stocke dans un seul dataframe :

-   Le nom du jeu de donn√©es (c.-√†-d. le pays)
-   La taille du jeu de donn√©es en octets
-   La date de derni√®re modification du jeu de donn√©es

Vous pouvez utiliser les fonctions `file.size()` et `file.mtime()` pour obtenir les deux derni√®res informations. Par exemple :

```{r}
file.size(here("data/new_hiv_infections_gho/Bangladesh.csv"))
file.mtime(here("data/new_hiv_infections_gho/Bangladesh.csv"))
```

Notez que vous n'avez pas besoin d'importer les CSV pour obtenir ces informations.

```{r eval = F}
# Lister les fichiers
csv_files <- list.files(path = "data/new_hiv_infections_gho", 
                        _____________________________________________)

for (i in _______________) {
  
  path <- csv_files[i]
  
  # Obtenir le nom du pays. Conseil : utilisez file_path_sans_ext et basename
  nom_pays <- _____________________________________
  
  # Obtenir la taille du fichier et la date de modification
  taille <- _____________________________________________
  date <- _____________________________________________
  
  # Dataframe pour cette it√©ration. Conseil : utilisez tibble() pour combiner les objets ci-dessus
  vih_ligne_df <- _____________________________________________
    
  # Stocker dans la liste. Conseil : utilisez des doubles crochets et l'index i
  liste_dataframes_____ <- vih_ligne_df
}

# Combiner en un seul dataframe
infos_fichiers_vih_final <- bind_rows(liste_dataframes)
```
:::

::: pratique
### Boucle de Filtrage des Donn√©es {.nonlist√© .nonnum√©rot√©}

Vous travaillerez √† nouveau avec le dossier des jeux de donn√©es sur le VIH de la question pr√©c√©dente. Voici un exemple d'un des jeux de donn√©es par pays de ce dossier :

```{r message=FALSE}
donnees_bangla <- read_csv(here("data/new_hiv_infections_gho/Bangladesh.csv"))
donnees_bangla
```

Votre t√¢che est de compl√©ter le mod√®le de boucle ci-dessous afin qu'il : - Importe chaque CSV du dossier - Filtre les donn√©es uniquement au sexe "F√©minin" - Sauvegarde chaque jeu de donn√©es filtr√© comme un CSV dans votre dossier `sorties`

Notez que dans ce cas, vous n'avez pas besoin de stocker les sorties dans une liste, car vous importez, modifiez puis exportez directement chaque jeu de donn√©es.

```{r eval = F}
# Lister les fichiers
csv_files <- list.files(path = "data/new_hiv_infections_gho", 
                        pattern = "*.csv", full.names = TRUE) 

for (fichier in _____________) {

  # Importer les donn√©es. Conseil : utilisez read_csv avec la variable `fichier` comme chemin
  donnees_vih _____________________________________________ 
  
  # Filtrer. Conseil : utilisez filter() et la variable `Sexe`
  donnees_vih_filtrees <- _____________________________________________ 
  
  # Nommer le fichier de sortie
  # Cette ligne est faite pour vous, mais assurez-vous de la comprendre
  nom_fichier_sortie <-  paste0(here(), "sorties/", "Feminin_", basename(fichier)))
  
  # Exporter. 
  write_csv(donnees_vih_filtrees, nom_fichier_sortie) 
}
```
:::

# Application R√©elle des Boucles 2 : G√©n√©ration de Plusieurs Graphiques

Une autre application courante des boucles est la g√©n√©ration de multiples graphiques pour diff√©rents groupes au sein d'un jeu de donn√©es. Nous utiliserons le jeu de donn√©es `strep_tb` du package `medicaldata` pour illustrer cela. Notre objectif est de cr√©er des graphiques d'inspection des cat√©gories pour chaque groupe d'am√©lioration radiologique √† 6 mois.

Commen√ßons par cr√©er un graphique pour l'un des groupes. Nous utiliserons `inspectdf::inspect_cat()` pour g√©n√©rer un graphique d'inspection des cat√©gories :

```{r}
cat_plot <- 
  medicaldata::strep_tb %>% 
  filter(radiologic_6m == "6_Considerable_improvement") %>% 
  inspectdf::inspect_cat() %>%
  inspectdf::show_plot()
cat_plot
```

Ce graphique nous offre un moyen rapide de visualiser la distribution des cat√©gories dans notre jeu de donn√©es.

Maintenant, nous voulons cr√©er des graphiques similaires pour chaque groupe d'am√©lioration radiologique dans le jeu de donn√©es. D'abord, identifions tous les groupes uniques en utilisant la fonction `unique` :

```{r}
niveaux_radiologiques_6m <- medicaldata::strep_tb$radiologic_6m %>% unique()
niveaux_radiologiques_6m
```

Ensuite, initialisons un objet liste vide o√π nous stockerons les graphiques.

```{r}
liste_graphiques_cat <- vector("list", length(niveaux_radiologiques_6m))
liste_graphiques_cat
```

Nous allons √©galement d√©finir les noms des √©l√©ments de la liste pour les groupes d'am√©lioration radiologique. C'est une √©tape facultative, mais cela facilite l'acc√®s aux graphiques sp√©cifiques plus tard.

```{r}
names(liste_graphiques_cat) <- niveaux_radiologiques_6m
liste_graphiques_cat
```

Finalement, nous utiliserons une boucle pour g√©n√©rer un graphique pour chaque groupe et le stocker dans la liste :

```{r}
for (niveau in niveaux_radiologiques_6m) {
  
  # G√©n√©rer le graphique pour chaque niveau
  cat_plot <- 
    medicaldata::strep_tb %>% 
    filter(radiologic_6m == niveau) %>% 
    inspectdf::inspect_cat() %>%
    inspectdf::show_plot()
  
  # Ajouter √† la liste
  liste_graphiques_cat[[niveau]] <- cat_plot
}
```

Pour acc√©der √† un graphique sp√©cifique, nous pouvons utiliser la syntaxe √† double crochet :

```{r}
liste_graphiques_cat[["6_Considerable_improvement"]]
```

Notez que dans ce cas, les √©l√©ments de la liste sont *nomm√©s*, plut√¥t que simplement num√©rot√©s. Cela est d√ª au fait que nous avons utilis√© la variable `niveau` comme index dans la boucle.

Pour afficher tous les graphiques √† la fois, nous appelons simplement la liste enti√®re.

```{r fig.height = 2, fig.show='hold', message=F}
liste_graphiques_cat
```

::: pratique
### Visualisation des cas de tuberculose {.unlisted .unnumbered}

Dans cet exercice, vous utiliserez des donn√©es de l'OMS du package `tidyr` pour cr√©er des graphiques en lignes montrant le nombre de nouveaux cas de tuberculose chez les enfants au fil des ann√©es dans les pays d'Am√©rique du Sud.

D'abord, nous pr√©parerons les donn√©es :

```{r}
cas_tb_enfants <- tidyr::who2 %>% 
  transmute(country, year, 
            tb_cases_children = sp_m_014 + sp_f_014 + sn_m_014 + sn_f_014) %>% 
  filter(country %in% c("Brazil", "Colombia", "Argentina", 
                        "Uruguay", "Chile", "Guyana"))  %>% 
  filter(year >= 2006)

cas_tb_enfants
```

Maintenant, remplissez les blancs dans le mod√®le ci-dessous pour cr√©er un graphique en lignes pour chaque pays en utilisant une boucle `for` :

```{r}
# Obtenez la liste des pays. Indice : Utilisez unique() sur la colonne pays
pays <- _____________________________________________ 

# Cr√©ez une liste pour stocker les graphiques. Indice : Initialisez une liste vide
graphiques_cas_tb_enfants <- vector("list", ________________)
names(graphiques_cas_tb_enfants) <- pays # D√©finissez les noms des √©l√©ments de la liste

# Boucle √† travers les pays
for (pays in _____________) { 
  
  # Filtrer les donn√©es pour chaque pays
  cas_tb_enfants_filtr√©s <- _____________________________________________ 
  
  # Cr√©er le graphique
  graphique_cas_tb_enfants <- _____________________________________________  
  
  #Ajouter √† la liste. Indice : Utilisez des doubles crochets
  graphiques_cas_tb_enfants[[pays]] <- graphique_cas_tb_enfants 
}

graphiques_cas_tb_enfants
```
:::

# Conclusion !

Dans cette le√ßon, nous nous sommes plong√©s dans les boucles `for` en R, d√©montrant leur utilit√© pour des t√¢ches simples jusqu'√† des analyses de donn√©es complexes impliquant plusieurs jeux de donn√©es et la g√©n√©ration de graphiques. Malgr√© la pr√©f√©rence de R pour les op√©rations vectoris√©es, les boucles for sont indispensables dans certains sc√©narios. Esp√©rons que cette le√ßon vous a √©quip√© des comp√©tences n√©cessaires pour mettre en ≈ìuvre avec confiance les boucles `for` dans divers contextes de traitement de donn√©es.

# Corrig√©

### Boucle Basique pour Convertir des Heures en Minutes

```{r}
heures <- c(3, 4, 5) # Vecteur d'heures

for (heure in heures) {
  minutes <- heure * 60
  print(minutes)
}
```

### Boucle Index√©e pour Convertir des Heures en Minutes

```{r}
heures <- c(3, 4, 5) # Vecteur d'heures

for (i in 1:length(heures)) {
  minutes <- heures[i] * 60
  print(minutes)
}
```

### Boucle de Calcul de l'IMC

```{r}
poids <- c(30, 32, 35) # Poids en kg
tailles <- c(1.2, 1.3, 1.4) # Tailles en m√®tres

for(i in 1:length(poids)) {
  imc <- poids[i] / (tailles[i] ^ 2)
  
  print(paste("Poids :", poids[i],
              "Taille :", tailles[i],
              "IMC :", imc))
}
```

### Conversion de la Taille de cm en m

```{r}
taille_cm <- c(180, 170, 190, 160, 150) # Tailles en cm 

taille_m <- vector("numeric", length = length(taille_cm)) 

for (i in 1:length(taille_cm)) {
  taille_m[i] <- taille_cm[i] / 100
}
taille_m
```

### Classification de la Temp√©rature

```{r}
temp_corporelle <- c(35, 36.5, 37, 38, 39.5) # Temp√©ratures corporelles en Celsius
vect_classif <- vector("character", length = length(temp_corps)) # vecteur de caract√®res

for (i in 1:length(temp_corps)) {
    # Ajoutez votre logique if-else ici
    if (temp_corporelle[i] < 36.5) {
        sortie <- "Hypothermie"
    } else if (temp_corporelle[i] <= 37.5) {
        sortie <- "Normal"
    } else {
        sortie <- "Fi√®vre"
    }
  
    # Instruction d'impression finale
    vect_classif[i] <- paste(temp_corporelle[i], "¬∞C est", sortie)
}
vect_classif
```

### Propri√©t√©s des Fichiers

```{r}
# En supposant que le chemin et la structure des fichiers sont corrects
fichiers_csv <- list.files(path = "data/new_hiv_infections_gho", 
                           pattern = "\\.csv$", full.names = TRUE)

liste_data_frames <- vector("list", length = length(fichiers_csv))

for (i in 1:length(fichiers_csv)) {
  
  chemin <- fichiers_csv[i]
  nom_pays <- tools::file_path_sans_ext(basename(chemin))
  
  taille <- file.size(chemin)
  date <- file.mtime(chemin)
  
  ligne_data_hiv <- tibble(pays = nom_pays, taille = taille, date = date)
    
  liste_data_frames[[i]] <- ligne_data_hiv
}

info_fichiers_hiv_final <- bind_rows(liste_data_frames)
info_fichiers_hiv_final
```

### Filtrage des Donn√©es en Boucle

```{r}
fichiers_csv <- list.files(path = "data/new_hiv_infections_gho", 
                           pattern = "*.csv", full.names = TRUE) 

for (fichier in fichiers_csv) {
  donnees_vih <- read_csv(fichier)
  
  donnees_vih_filtrees <- donnees_vih %>% filter(Sex == "Female")
  
  nom_fichier_sortie <- paste0(here(), "/outputs/", "Female_", basename(fichier))
  
  write_csv(donnees_vih_filtrees, nom_fichier_sortie) 
}
```

### Visualisation des Cas de Tuberculose

```{r}
# En supposant que tb_child_cases est un dataframe avec les colonnes n√©cessaires
pays <- unique(cas_tb_enfants$country)

# Cr√©e une liste pour stocker les graphiques
graphiques_cas_tb_enfants <- vector("list", length(pays))
names(graphiques_cas_tb_enfants) <- pays

# Boucle √† travers les pays
for (nom_pays in pays) { 
  
  # Filtre les donn√©es pour chaque pays
  cas_tb_enfants_filtres <- filter(cas_tb_enfants, country == nom_pays)
  
  # Cr√©e le graphique
  graphique_cas_tb_enfant <- ggplot(cas_tb_enfants_filtres, aes(x = year, y = tb_cases_children)) +
    geom_line() +
    ggtitle(paste("Cas de TB chez les Enfants -", nom_pays))
  
  # Ajoute au liste
  graphiques_cas_tb_enfants[[nom_pays]] <- graphique_cas_tb_enfant 
}

graphiques_cas_tb_enfants[["Uruguay"]]
```

# Contributeurs {.unlisted .unnumbered}

Les membres suivants de l'√©quipe ont contribu√© √† cette le√ßon :

`r tgc_contributors_list(ids = c("sabina", "kendavidn", "guy"))`

------------------------------------------------------------------------

# R√©f√©rences {.unnumbered .unlisted}

Du mat√©riel dans cette le√ßon a √©t√© adapt√© des sources suivantes :

-   Barnier, Julien. "Introduction √† R et au tidyverse." <https://juba.github.io/tidyverse>

-   Wickham, Hadley; Grolemund, Garrett. "R for Data Science." <https://r4ds.had.co.nz/>

-   Wickham, Hadley; Grolemund, Garrett. "R for Data Science (2e)." <https://r4ds.hadley.nz/>