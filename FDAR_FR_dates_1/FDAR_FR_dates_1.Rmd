---
title: 'Dates 1: Reconna√Ætre et Savoir Formatter des Dates'
output:
  html_document:
    number_sections: true
    toc: true
    toc_float: true
    css: !expr here::here("global/style/style.css")
    highlight: kate
editor_options: 
  chunk_output_type: console
  markdown: 
    wrap: 72
---

```{r, echo = F, message = F, warning = F}
# Load packages 
if(!require(pacman)) install.packages("pacman")
pacman::p_load(rlang, tidyverse, knitr, here, reactable, gt, flextable)

## functions
source(here::here("global/functions/misc_functions.R"))

## default render
registerS3method("reactable_5_rows", "data.frame", reactable_5_rows)
knitr::opts_chunk$set(class.source = "tgc-code-block")

# Set to french for french characters
Sys.setlocale("LC_CTYPE", "fr_FR.UTF-8")
```

# Introduction

Comprendre comment manipuler les dates est une comp√©tence cruciale lorsque l'on travaille avec des donn√©es de sant√©. Les calendriers de vaccination, la surveillance des maladies, et les changements dans les indicateurs de sant√© √† l'√©chelle de la population n√©cessitent tous de travailler avec des dates. Dans cette le√ßon, nous allons apprendre comment R stocke et affiche les dates, ainsi que comment les manipuler, les analyser et les formatter efficacement. Commen√ßons !

# Learning Objectives

-   Vous comprenez comment les dates sont stock√©es et manipul√©es dans R

-   Vous comprenez comment convertir des cha√Ænes de caract√®res en dates

-   Vous savez g√©rer les colonnes de dates de formats mixtes

-   Vous √™tes capable de changer l'affichage des dates

# Packages

Veuillez charger les packages n√©cessaires pour cette le√ßon avec le code ci-dessous :

```{r warning = F, message = F, echo = T}
if(!require(pacman)) install.packages("pacman")
pacman::p_load(tidyverse, 
               lubridate)

```

------------------------------------------------------------------------

# Datasets

## PID Malawi

Le premier jeu de donn√©es que nous utiliserons contient des donn√©es li√©es aux pulv√©risation intradomiciliaire d'insecticide (PID) dans le cadre des efforts de lutte contre le paludisme entre 2014 et 2019 √† Illovo, au Malawi. Notez que le jeu de donn√©es est au format long, chaque ligne repr√©sentant une p√©riode pendant laquelle les PID ont eu lieu dans un village. √âtant donn√© que le m√™me village est pulv√©ris√© √† plusieurs reprises √† diff√©rents moments, les noms de village se r√©p√®tent. Les jeux de donn√©es au format long sont souvent utilis√©s lorsque l'on traite des donn√©es de s√©ries chronologiques avec des mesures r√©p√©t√©es, car ils sont plus faciles √† manipuler pour les analyses et les visualisations.

```{r message=FALSE}
pid <- read_csv(here("data/Illovo_PID.csv"))
```

```{r render = reactable_5_rows}
pid
```

Les variables incluses dans le jeu de donn√©es sont les suivantes :

-   `village`: nom du village o√π la PID a eu lieu
-   `cible_PID`: nombre de structures cibl√©es pour la PID
-   `reelle_PID`: nombre de structures r√©ellement PID
-   `date_debut_defaut`: le jour o√π la PID a commenc√©, au format par d√©faut "aaaa-mm-jj"
-   `date_fin_defaut`: jour o√π la PID s'est termin√©e, au format par d√©faut "aaaa-mm-jj"
-   `date_debut_typique`: jour o√π la pulv√©risation a commenc√©, au format "jj/mm/aaaa"
-   `date_debut_longue`: jour o√π la PID a commenc√©, avec le mois √©crit en entier, jour √† deux chiffres, puis ann√©e √† quatre chiffres
-   `date_debut_mixte`: jour o√π la PID a commenc√© avec un m√©lange de diff√©rents formats

## S√©jours hospitaliers

Le deuxi√®me jeu de donn√©es constitue des donn√©es factices de s√©jours hospitaliers simul√©s. Il contient les dates d'admission et de sortie de 150 patients. Tout comme le jeu de donn√©es PID, les dates d'admission sont format√©es de diff√©rentes mani√®res afin que vous puissiez exercer vos comp√©tences en mati√®re de formatage.

```{r message=FALSE}
sej_hosp <- read_csv(here("data/sejours_hospitaliers.csv"))
```

```{r render = reactable_5_rows}
sej_hosp
```

------------------------------------------------------------------------

# Introduction aux Dates en R

Dans R, il existe une classe sp√©cifique con√ßue pour g√©rer les dates, appel√©e `Date`. Le format par d√©faut pour cette classe est "aaaa-mm-jj". Par exemple, le 31 d√©cembre 2000 serait repr√©sent√© comme `2000-12-31`.

Cependant, si vous entrez simplement une telle cha√Æne de caract√®res de date, R va initialement la consid√©rer comme un caract√®re :

```{r}
class("2000-12-31")
```

Si nous voulons cr√©er une `Date`, nous pouvons utiliser la fonction `as.Date()` et √©crire la date en suivant le format par d√©faut :

```{r}
my_date <- as.Date("2000-12-31")
class(my_date)
```

::: watch-out
Notez le "D" majuscule dans la fonction `as.Date()` !
:::

Maintenant que vos objets sont de la classe `Date`, vous pouvez maintenant faire des calculs simples comme trouver la diff√©rence entre deux dates :

```{r}
as.Date("2000-12-31") - as.Date("2000-12-20")
```

Ceci ne serait bien s√ªr pas possible si vous aviez de simples caract√®res :

```{r eval = F}
"2000-12-31" - "2000-12-20"
```

```         
Error in "2000-12-31" - "2000-12-20" : 
  non-numeric argument to binary operator
```

De nombreuses autres op√©rations s'appliquent uniquement √† la classe `Date`. Nous les explorerons en d√©tail plus tard.

------------------------------------------------------------------------

Le format par d√©faut pour `as.Date()` est "aaaa-mm-jj". D'autres formats courants comme "mm/jj/aaaa" ou "jj mois, aaaa" ne fonctionneront pas par d√©faut :

```{r, eval=FALSE}
as.Date("12/31/2000") 
as.Date("31 dec, 2000")
```

Cependant, R acceptera √©galement "/" au lieu de "-" tant que l'ordre est toujours "aaaa/mm/jj". Les dates s'afficheront au format par d√©faut "aaaa-mm-jj" :

```{r}
as.Date("2000/12/31")
```

En r√©sum√©, les seuls formats qui fonctionnent par d√©faut sont "aaaa-mm-jj" et "aaaa/mm/jj". Plus tard dans cette le√ßon, nous allons apprendre √† g√©rer diff√©rents formats de date et on vous donnerons des conseils sur la coercion de dates import√©es sous forme de cha√Ænes de caract√®res dans la classe `Date`. Pour l'instant, l'essentiel est de comprendre que les dates ont leur propre classe avec ses propres propri√©t√©s de formatage.

::: side-note
Il existe une autre classe de donn√©es utilis√©e pour les dates, appel√©e `POSIXct`. Cette classe g√®re les dates et heures ensemble, et le format par d√©faut est "aaaa-mm-jj hh:mm:ss". Cependant, dans le cadre de ce cours, nous ne travaillerons pas avec cette classe car ce niveau d'analyse est beaucoup moins courant dans le domaine de la sant√© publique.
:::

------------------------------------------------------------------------

# Conversion de cha√Ænes de caract√®res en dates

Revenons √† nos donn√©es PID et regardons comment R a class√© nos variables de date !

```{r render = knit_print}
pid %>% 
  select(contains("date"))
```

Comme nous pouvons le voir, les deux colonnes reconnues comme des dates sont `date_debut_defaut` et `date_fin_defaut`, qui suivent le format "aaaa-mm-jj" de R :

```         
   date_debut_defaut  date_fin_defaut  date_debut_typique
   üëâ<date>üëà          üëâ<date>üëà        <chr>               
 1 2014-04-07          2014-04-17        07/04/2014       
 2 2014-04-22          2014-04-27        22/04/2014
```

Toutes les autres colonnes de date dans notre jeu de donn√©es ont √©t√© import√©es comme des cha√Ænes de caract√®res ("chr"), et si nous voulons les transformer en dates, nous devons indiquer √† R qu'elles sont des dates, ainsi que sp√©cifier l'ordre des composants de la date.

Vous vous demandez peut-√™tre pourquoi il est n√©cessaire de sp√©cifier l'ordre. Eh bien, imaginez qu'on ait une date √©crite `01-02-03`. Est-ce le 2 janvier 2003 ? Le 1er f√©vrier 2003 ? Ou peut-√™tre le 2 mars 2001 ? Il existe tellement de conventions diff√©rentes pour √©crire les dates que si R devait deviner le format, il y aurait in√©vitablement des cas o√π il se tromperait.

Pour r√©soudre ce probl√®me, il existe deux fa√ßons principales de convertir des cha√Ænes en dates qui impliquent de sp√©cifier l'ordre des composants. La premi√®re approche s'appuie sur les fonctions natives de R (appel√© courrament par son nom anglais, "Base R"), et la seconde utilise un package appel√© `lubridate` de la biblioth√®que `tidyverse`. Regardons d'abord la fonction native de R !

## Avec les fonctions natives de R (Base R)

Dans l'introduction nous avons vu comment convertir des cha√Ænes de caract√®res en dates avec les fonctions natives de R, plus pr√©cisement avec la fonction `as.Date()`. Essayons de l'appliquer √† notre colonne `date_debut_typique` sans sp√©cifier l'ordre des composants pour voir ce qui se passe.

```{r, render = reactable_5_rows}
pid %>%
  mutate(date_debut_typique = as.Date(date_debut_typique)) %>% 
  select(date_debut_typique)
```

√âvidemment, ce n'est pas du tout ce que nous voulions ! Si nous regardons la variable d'origine, nous pouvons voir qu'elle est format√©e "jj/mm/aaaa". R a essay√© d'appliquer son format par d√©faut √† ces dates, ce qui donne ces r√©sultats √©tranges.

::: watch-out
Souvent, R vous retournera un message d'erreur si vous essayez de convertir des charact√®res ambigu√´s en dates sans sp√©cifier l'ordre de leurs composants. Mais, comme nous venons de le voir, ce n'est pas toujours le cas ! V√©rifiez toujours que votre code s'est ex√©cut√© comme pr√©vu et ne vous fiez jamais seulment aux messages d'erreur pour vous assurer que vos transformations de donn√©es ont fonctionn√© correctement.
:::

Pour que R interpr√®te correctement nos dates, nous devons utiliser l'option `format` et sp√©cifier les composants de notre date √† l'aide d'une s√©rie de symboles. Le tableau ci-dessous montre les symboles pour les composants de format les plus courants :

| Composant                                                                | Symbol | Exemple  |
|-------------------------------------------------|------------|------------|
| Ann√©e, en format long (4 chiffres)                                       | %Y     | 2023     |
| Ann√©e, format abr√©g√© (2 chiffres)                                        | %y     | 23       |
| Mois, en format num√©rique (1-12)                                         | %m     | 01       |
| Mois √©crit en format long                                                | %B     | janvier  |
| Mois √©crit en format abr√©g√©                                              | %b     | janv     |
| Jour du mois                                                             | %d     | 31       |
| Jour de la semaine, en format num√©rqiue (1-7 en commen√ßant par dimanche) | %u     | 5        |
| Jour de la semaine √©crit en format long                                  | %A     | vendredi |
| Jour de la semaine √©crit en format abr√©g√©                                | %a     | ven      |

\*\*Add note about systems computer language

Si on revient √† notre variable d'origine `date_debut_typique`, on voit qu'elle est format√©e "jj/mm/aaaa", ce qui correspond au jour du mois, suivi du mois repr√©sent√© par un nombre (01-12), puis de l'ann√©e en format long (4 chiffres). Si nous utilisons ces symboles, nous devrions obtenir les r√©sultats que nous cherchons.

```{r, render = reactable_5_rows}
pid %>%
  mutate(date_debut_typique = as.Date(date_debut_typique, format="%d%m%Y")) 
```

Bon, ce n'est toujours pas ce que nous voulions. Avez-vous une id√©e de la raison pour laquelle √ßa n'a pas march√© ? C'est parce que les composants de nos dates sont s√©par√©s par un slash "/", que nous devons inclure dans notre option de format. Essayons √† nouveau !

```{r, render = reactable_5_rows}
pid %>%
  mutate(date_debut_typique = as.Date(date_debut_typique, format="%d/%m/%Y"))%>% 
  select(date_debut_typique)
```

Cette fois √ßa a parfaitement fonctionn√© ! Maintenant nous savons comment convertir des cha√Ænes de caract√®res en dates en utilisant la fonction native de R `as.Date()` avec l'option `format`.

::: r-practice

**Convertir date longue**

Essayez de convertir la colonne `date_debut_longue` des donn√©es PID en classe `Date`. N'oubliez pas d'inclure tous les √©l√©ments dans l'option de format, y compris les symboles qui s√©parent les composants de la date !
:::

::: r-practice

**Trouver les erreurs de code**

Est-ce que vous arrivez √† trouver toutes les erreurs dans le code suivant ?

```{r}
as.Date("26 juin, 1987", format = "%d%b%y")

```
:::

## Avec `lubridate`

Le package `lubridate` nous donne une fa√ßon beaucoup plus simple de convertir des cha√Ænes de caract√®res en dates que les fonctions natives de R. Avec ce package, il suffit de sp√©cifier l'ordre dans lequel apparaissent l'ann√©e, le mois, et le jour en utilisant respectivement les lettres "y" pour l'ann√©e, "m" pour le mois et "d" pour le jour (correspondant √† "year", "month" et "day" en anglais). Avec ces fonctions, ce n'est pas n√©cessaire de sp√©cifier les caract√®res qui s√©parent les diff√©rents composants de la date.

Regardons quelques exemples :

```{r}
mdy("04/30/2002")

dmy("30 avril 2002")

ymd("2002-04-03")
```

Facile ! Et comme nous pouvons le voir, nos dates sont affich√©es en utilisant le format R par d√©faut. Maintenant que nous arrivons √† utiliser les fonctions du package lubridate, essayons de les appliquer √† la variable `date_debut_longue` de notre jeu de donn√©es.

```{r, render = reactable_5_rows}
pid %>%
  mutate(date_debut_longue = mdy(date_debut_longue)) %>% 
  select(date_debut_longue) 
```

Parfait, c'est exactement ce qu'on voulait !

::: r-practice
**Convertir date typique**
Essayez de convertir la colonne `date_debut_typique` du jeu de donn√©es PID en classe `Date` en utilisant les fonctions du package `lubridate`.
:::

::: r-practice

**Formatage de base et lubridate**

Le tableau suivant contient les formats trouv√©s dans les colonnes `date_adm_abrege` et `date_adm_mixte` de notre jeu de donn√©es de patients hospitalis√©s. Est ce que vous arrivez √† remplir les cellules vides ?

| Exemple     | Base R   | Lubridate |
|-------------|----------|-----------|
| 07 d√©c 2022 |          |           |
| 03-27-2022  |          | mdy       |
| 28.04.2022  |          |           |
|             | %Y/%m/%d |           |
:::

Maintenant que nous connaissons deux fa√ßons de convertir des cha√Ænes de caract√®res en classe `Date` en sp√©cifiant l'ordre des composants ! Mais que faire si nous avons plusieurs formats de date dans la m√™me colonne ? Passons √† la section suivante pour le d√©couvrir !

------------------------------------------------------------------------

# G√©rer des dates mixtes avec `lubridate::parse_date_time()`

Lorsque l'on travaille avec des dates, il arrive parfois d'avoir diff√©rents formats au sein de la m√™me colonne. Heureusement, lubridate dispose d'une fonction pratique √† cet effet ! La fonction `parse_date_time()` est similaire aux fonctions que nous avons vues pr√©c√©demment dans le package lubridate, mais avec plus de flexibilit√© et la possibilit√© d'inclure plusieurs formats de date dans le m√™me appel en utilisant l'argument `orders`. Jetons un rapide coup d'≈ìil √† son fonctionnement avec quelques exemples simples.

Pour comprendre comment utiliser `parse_date_time()`, appliquons-le √† une seule cha√Æne de caract√®res que nous voulons convertir en date.

```{r}
parse_date_time("30/07/2001", orders="dmy")
```

C'est parfait ! Utiliser la fonction de cette fa√ßon est √©quivalent √† utiliser la fonction `dmy()`. Cependant, la vraie puissance de `parse_date_time()` se r√©v√®le lorsque nous avons plusieurs dates avec des formats diff√©rents.

::: side-note
La partie "UTC" est le fuseau horaire par d√©faut utilis√© pour analyser la date. Celui-ci peut √™tre modifi√© avec l'argument `tz=`, mais changer le fuseau horaire par d√©faut est rarement n√©cessaire lorsqu'on traite uniquement de dates, contrairement √† des dates-heures.
:::

Regardons un autre exemple avec deux formats diff√©rents :

```{r}
parse_date_time(c("1 jan 2000", "07/30/2001"), orders=c("dmy", "mdy"))
```

Notez que cet exemple sp√©cifique fonctionnera toujours si vous changez l'ordre dans lequel vous pr√©sentez les formats :

```{r}
parse_date_time(c("1 jan 2000", "07/30/2001"), orders=c("mdy", "dmy"))
```

Le dernier bloc de code fonctionne toujours car `parse_date_time()` v√©rifie chaque format sp√©cifi√© dans l'argument `orders` jusqu'√† trouver une correspondance. Cela signifie que, que vous listiez "dmy" en premier ou "mdy" en premier, il essaiera les deux formats sur chaque cha√Æne de date pour voir lequel convient. L'ordre n'a pas d'importance pour des cha√Ænes de dates distinctes qui ne peuvent correspondre qu'√† un seul format.

Cependant, lorsque l'on traite des dates ambigu√´s comme "01/02/2000" ou "01/03/2000", qui pourraient √™tre interpr√©t√©es soit comme le 2 janvier et le 3 janvier, soit comme le 1er f√©vrier et le 1er mars respectivement, l'ordre dans `orders` a vraiment de l'importance :

```{r}
parse_date_time(c("01/02/2000", "01/03/2000"), orders=c("mdy", "dmy"))
```

Dans l'exemple ci-dessus, parce que "mdy" est list√© en premier, la fonction interpr√®te les dates comme √©tant le 2 janvier et le 3 janvier. Mais, si vous changiez l'ordre et listiez "dmy" en premier, elle interpr√©terait les dates comme √©tant le 1er f√©vrier et le 1er mars :

```{r}
parse_date_time(c("01/02/2000", "01/03/2000"), orders=c("dmy", "mdy"))
```

Par cons√©quent, lorsqu'il y a une ambigu√Øt√© potentielle dans les cha√Ænes de dates, l'ordre dans lequel vous sp√©cifiez les formats devient tr√®s important.

::: r-practice

**Utilisation de parse_date_time**

Les dates dans le code ci-dessous sont le 9 novembre 2002, le 4 d√©cembre 2001 et le 5 juin 2003. Compl√©tez le code pour les convertir de caract√®res en dates.

```{r echo=TRUE, eval=FALSE}
parse_date_time(c("11/09/2002", "12/04/2001", "2003-06-05"), orders=c(...))
```
:::

------------------------------------------------------------------------

Revenons √† notre jeu de donn√©es, cette fois sur la colonne date_debut_mixte.

```{r render = reactable_5_rows}
pid %>%
  select("date_debut_mixte") 
```

√âtant donn√© que cette colonne a √©t√© cr√©√©e sp√©cifiquement pour ce cours, nous connaissons les diff√©rents formats de date qu'elle contient. Dans votre propre travail, assurez-vous toujours de conna√Ætre le format de vos dates, car nous savons que certaines peuvent √™tre ambigu√´s.

Ici, nous travaillons avec quatre formats diff√©rents, plus pr√©cis√©ment :

-   aaaa/mm/jj

-   jj mois aaaa

-   jj-mm-aaaa

-   mm/jj/aaaa

Voyons √† quoi cela ressemble dans lubridate par rapport au R de base :

| Example date | Base R   | Lubridate |
|--------------|----------|-----------|
| 2014/05/13   | %Y/%m/%d | ymd       |
| 13 mai 2014  | %B%d%Y   | dmy       |
| 27-05-2014   | %d-%m-%Y | dmy       |
| 07/21/14     | %m/%d/%y | mdy       |

Ici, lubridate consid√®re qu'il n'y a que trois formats diff√©rents ("ymd", "mdy" et "dmy"). Maintenant que nous savons comment nos donn√©es sont format√©es, nous pouvons utiliser la fonction parse_date_time() pour les changer en classe `Date`.

```{r render = kable_5_rows}
pid %>%
  select(date_debut_mixte) %>%
  mutate(date_debut_mixte = parse_date_time(date_debut_mixte, orders = c("mdy", "ymd", "dmy")))
```

C'est beaucoup mieux ! R a correctement format√© notre colonne et elle est d√©sormais reconnue comme une variable de type date. Vous vous demandez peut-√™tre si l'ordre des formats est n√©cessaire dans ce cas. Essayons un ordre diff√©rent pour le d√©couvrir !

```{r render = kable_5_rows}
pid %>%
  select(date_debut_mixte) %>%
  mutate(date_debut_mixte = parse_date_time(date_debut_mixte, orders = c("dmy", "mdy", "ymd")))
```

Cela ne semble pas avoir fait de diff√©rence, les dates sont toujours format√©es correctement ! Si vous vous demandez pourquoi l'ordre importait dans notre exemple pr√©c√©dent mais pas ici, c'est li√© au fonctionnement de la fonction `parse_date_time()`. Lorsqu'elle re√ßoit plusieurs ordres, la fonction tente de trouver la meilleur correspondance pour un sous-ensemble d'observations en consid√©rant les s√©parateurs de dates et en favorisant l'ordre dans lequel les formats ont √©t√© fournis. Dans notre dernier exemple, les deux dates √©taient s√©par√©es par un "/" et les deux formats fournis ("dmy" et "mdy") √©taient des formats possibles, la fonction a donc favoris√© le premier donn√©.

```{r}
parse_date_time(c("01/02/2000", "01/03/2000"), orders=c("mdy", "dmy"))
parse_date_time(c("01/02/2000", "01/03/2000"), orders=c("dmy", "mdy"))
```

Dans nos donn√©es PID, nous avions aussi des formats qui pouvaient √™tre ambigus comme jj-mm-aaaa et mm/jj/aaaa. Mais ici, la fonction peut utiliser les s√©parateurs comme indice pour trouver des r√®gles de formatage et distinguer les diff√©rents formats. Par exemple, si nous avons une date ambigu√´ comme `01-02-2000`, mais aussi une date avec le m√™me s√©parateur qui n'est pas ambigu√´ comme `30-05-2000,` la fonction d√©terminera que la r√©ponse la plus probable est que toutes les dates s√©par√©es par un "-" sont au format jj-mm-aaaa, et appliquera cette r√®gle de mani√®re r√©cursive aux donn√©es d'entr√©e. Si vous voulez en savoir plus sur les d√©tails de la fonction `parse_date_time()`, cliquez ici ou ex√©cutez `?parse_date_time` dans R !

::: r-practice

**Utilisation de parse_date_time avec adm_date_messy**
A l'aide du tableau que vous avez rempli pour l'exercice de la ***Section 6.2 Lubridate***, utilisez la fonction `parse_date_time()` pour changer la classe de la colonne `date_adm_mixte` du jeu de donn√©es de patients hospitalis√©s en `Date`, `ip`!

:::

------------------------------------------------------------------------

# Modifier l'Affichage des Dates

Jusqu'√† pr√©sent, nous avons converti des cha√Ænes de caract√®res de divers formats en classe `Date` qui suit un format par d√©faut "aaaa-mm-jj". Mais que faire si nous voulons que nos dates s'affichent dans un format sp√©cifique qui est diff√©rent de ce format par d√©faut, comme lorsque nous cr√©ons des rapports ou des graphiques ? Cela est rendu possible en reconvertissant les dates en cha√Ænes de caract√®res en utilisant la fonction `format()`!

La fonction `format()` vous offre une grande flexibilit√© pour personnaliser l'apparence de vos dates selon vos pr√©f√©rences. Vous pouvez accomplir cela en utilisant les m√™mes symboles que nous avons vu avec la fonction `as.Date()`, en les ordonnant pour correspondre √† l'apparence souhait√©e de votre date. Revenons au tableau pour rafra√Æchir notre m√©moire sur la fa√ßon dont les diff√©rentes parties d'une date sont repr√©sent√©es dans R.

| Composant                                                                | Symbol | Exemple  |
|-------------------------------------------------|------------|------------|
| Ann√©e, en format long (4 chiffres)                                       | %Y     | 2023     |
| Ann√©e, format abr√©g√© (2 chiffres)                                        | %y     | 23       |
| Mois, en format num√©rique (1-12)                                         | %m     | 01       |
| Mois √©crit en format long                                                | %B     | janvier  |
| Mois √©crit en format abr√©g√©                                              | %b     | janv     |
| Jour du mois                                                             | %d     | 31       |
| Jour de la semaine, en format num√©rqiue (1-7 en commen√ßant par dimanche) | %u     | 6        |
| Jour de la semaine √©crit en format long                                  | %A     | vendredi |
| Jour de la semaine √©crit en format abr√©g√©                                | %a     | ven      |

Tr√®s bien, essayons maintenant d'appliquer cette fonction √† une seule date. Disons que nous voulons que la date `2000-01-31` s'affiche comme "31 janv. 2000".

```{r}
my_date <- as.Date("2000-01-31")
format(my_date, "%d %b. %Y")
```

::: r-practice
**Cr√©er un vecteur de dates**
Cr√©ez un vecteur de dates contenant la date du 7 mai 2018. Formatez ensuite la date en jj/mm/aaaa en tant que caract√®re.
:::

Maintenant, essayons de l'utiliser sur nos donn√©es PID. Cr√©ons une nouvelle variable appel√©e `date_debut_char` √† partir de la colonne `date_debut_defaut`. Nous allons la formater pour qu'elle s'affiche comme jj-mm-aaaa.

```{r, render = reactable_5_rows}
pid %>% 
  mutate(date_debut_char = format(date_debut_defaut, "%d-%m-%Y")) %>% 
  select(date_debut_defaut)
```

Super ! Faisons un dernier exemple en utilisant notre variable `date_fin_defaut` et en la formatant comme jj mois aaaa.

```{r, render = reactable_5_rows}
pid %>% 
  mutate(end_date_char = format(date_fin_defaut, "%d %B %Y")) %>% 
  select(date_fin_defaut)
```

G√©nial !

------------------------------------------------------------------------

# EN R√âSUM√â {.unnumbered}

F√©licitations pour avoir termin√© la premi√®re le√ßon sur les dates ! Maintenant que vous comprenez comment les dates sont stock√©es, affich√©es et format√©es dans R, vous pouvez passer √† la section suivante o√π vous apprendrez √† effectuer des manipulations avec les dates et √† cr√©er des graphiques de s√©ries temporelles de base.

------------------------------------------------------------------------

# Answer Key {.unnumbered}

**Convertir une date longue**

```{r echo=TRUE, eval=FALSE}
irs <- irs %>%
  mutate(start_date_long = as.Date(start_date_long, format="%B, %d %Y"))
```

**Trouver les erreurs de code**

```{r echo=TRUE, eval=FALSE}
as.Date("Juin 26, 1987", format = "%B %d, %Y")
```

**Convertir une date typique**

```{r echo=TRUE, eval=FALSE}
irs %>%
  mutate(start_date_typical = dmy(start_date_typical))
```


**Formatage de base et lubridate**

| Date example | Base R    | Lubridate |
|--------------|-----------|-----------|
| 07 dec, 2022 | %b %d, %Y | dmy       |
| 03-27-2022   | %m-%d-%Y  | mdy       |
| 28.04.2022   | %d.%m.%Y  | dmy       |
| 2021/05/23   | %Y/%m/%d  | ymd       |

**Utilisation de parse_date_time**

```{r echo=TRUE, eval=FALSE}
parse_date_time(c("11/09/2002", "12/04/2001", "2003-06-05"), orders=c("mdy", "ymd"))
```


**Utilisation de parse_date_time avec adm_date_messy**

```{r echo=TRUE, eval=FALSE}
ip %>%
  mutate(adm_date_messy = parse_date_time(adm_date_messy, orders = c("mdy", "dmy", "ymd")))
```

**Cr√©er un vecteur de dates**

```{r echo=TRUE, eval=FALSE}
my_date <- as.Date("2018-05-07")
format(my_date, "%m/%d/%Y")
```

------------------------------------------------------------------------

# Contributors {.unlisted .unnumbered}

The following team members contributed to this lesson:

`r tgc_contributors_list(c("amckinley", "kendavidn", "guy"))`